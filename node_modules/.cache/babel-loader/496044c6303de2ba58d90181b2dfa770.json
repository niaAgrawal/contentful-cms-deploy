{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global['fast-copy'] = factory());\n})(this, function () {\n  'use strict';\n\n  var toStringFunction = Function.prototype.toString;\n  var create = Object.create,\n      defineProperty = Object.defineProperty,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      getOwnPropertyNames = Object.getOwnPropertyNames,\n      getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      getPrototypeOf = Object.getPrototypeOf;\n  var _a = Object.prototype,\n      hasOwnProperty = _a.hasOwnProperty,\n      propertyIsEnumerable = _a.propertyIsEnumerable;\n  /**\r\n   * @enum\r\n   *\r\n   * @const {Object} SUPPORTS\r\n   *\r\n   * @property {boolean} SYMBOL_PROPERTIES are symbol properties supported\r\n   * @property {boolean} WEAKMAP is WeakMap supported\r\n   */\n\n  var SUPPORTS = {\n    SYMBOL_PROPERTIES: typeof getOwnPropertySymbols === 'function',\n    WEAKMAP: typeof WeakMap === 'function'\n  };\n  /**\r\n   * @function createCache\r\n   *\r\n   * @description\r\n   * get a new cache object to prevent circular references\r\n   *\r\n   * @returns the new cache object\r\n   */\n\n  var createCache = function () {\n    if (SUPPORTS.WEAKMAP) {\n      return new WeakMap();\n    } // tiny implementation of WeakMap\n\n\n    var object = create({\n      has: function (key) {\n        return !!~object._keys.indexOf(key);\n      },\n      set: function (key, value) {\n        object._keys.push(key);\n\n        object._values.push(value);\n      },\n      get: function (key) {\n        return object._values[object._keys.indexOf(key)];\n      }\n    });\n    object._keys = [];\n    object._values = [];\n    return object;\n  };\n  /**\r\n   * @function getCleanClone\r\n   *\r\n   * @description\r\n   * get an empty version of the object with the same prototype it has\r\n   *\r\n   * @param object the object to build a clean clone from\r\n   * @param realm the realm the object resides in\r\n   * @returns the empty cloned object\r\n   */\n\n\n  var getCleanClone = function (object, realm) {\n    if (!object.constructor) {\n      return create(null);\n    }\n\n    var Constructor = object.constructor;\n    var prototype = object.__proto__ || getPrototypeOf(object);\n\n    if (Constructor === realm.Object) {\n      return prototype === realm.Object.prototype ? {} : create(prototype);\n    }\n\n    if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n      try {\n        return new Constructor();\n      } catch (_a) {}\n    }\n\n    return create(prototype);\n  };\n  /**\r\n   * @function getObjectCloneLoose\r\n   *\r\n   * @description\r\n   * get a copy of the object based on loose rules, meaning all enumerable keys\r\n   * and symbols are copied, but property descriptors are not considered\r\n   *\r\n   * @param object the object to clone\r\n   * @param realm the realm the object resides in\r\n   * @param handleCopy the function that handles copying the object\r\n   * @returns the copied object\r\n   */\n\n\n  var getObjectCloneLoose = function (object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n\n    for (var key in object) {\n      if (hasOwnProperty.call(object, key)) {\n        clone[key] = handleCopy(object[key], cache);\n      }\n    }\n\n    if (SUPPORTS.SYMBOL_PROPERTIES) {\n      var symbols = getOwnPropertySymbols(object);\n      var length_1 = symbols.length;\n\n      if (length_1) {\n        for (var index = 0, symbol = void 0; index < length_1; index++) {\n          symbol = symbols[index];\n\n          if (propertyIsEnumerable.call(object, symbol)) {\n            clone[symbol] = handleCopy(object[symbol], cache);\n          }\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * @function getObjectCloneStrict\r\n   *\r\n   * @description\r\n   * get a copy of the object based on strict rules, meaning all keys and symbols\r\n   * are copied based on the original property descriptors\r\n   *\r\n   * @param object the object to clone\r\n   * @param realm the realm the object resides in\r\n   * @param handleCopy the function that handles copying the object\r\n   * @returns the copied object\r\n   */\n\n\n  var getObjectCloneStrict = function (object, realm, handleCopy, cache) {\n    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively\n\n    cache.set(object, clone);\n    var properties = SUPPORTS.SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);\n    var length = properties.length;\n\n    if (length) {\n      for (var index = 0, property = void 0, descriptor = void 0; index < length; index++) {\n        property = properties[index];\n\n        if (property !== 'callee' && property !== 'caller') {\n          descriptor = getOwnPropertyDescriptor(object, property);\n\n          if (descriptor) {\n            // Only clone the value if actually a value, not a getter / setter.\n            if (!descriptor.get && !descriptor.set) {\n              descriptor.value = handleCopy(object[property], cache);\n            }\n\n            try {\n              defineProperty(clone, property, descriptor);\n            } catch (error) {\n              // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n              clone[property] = descriptor.value;\n            }\n          } else {\n            // In extra edge cases where the property descriptor cannot be retrived, fall back to\n            // the loose assignment.\n            clone[property] = handleCopy(object[property], cache);\n          }\n        }\n      }\n    }\n\n    return clone;\n  };\n  /**\r\n   * @function getRegExpFlags\r\n   *\r\n   * @description\r\n   * get the flags to apply to the copied regexp\r\n   *\r\n   * @param regExp the regexp to get the flags of\r\n   * @returns the flags for the regexp\r\n   */\n\n\n  var getRegExpFlags = function (regExp) {\n    var flags = '';\n\n    if (regExp.global) {\n      flags += 'g';\n    }\n\n    if (regExp.ignoreCase) {\n      flags += 'i';\n    }\n\n    if (regExp.multiline) {\n      flags += 'm';\n    }\n\n    if (regExp.unicode) {\n      flags += 'u';\n    }\n\n    if (regExp.sticky) {\n      flags += 'y';\n    }\n\n    return flags;\n  }; // utils\n\n\n  var isArray = Array.isArray;\n\n  var GLOBAL_THIS = function () {\n    if (typeof self !== 'undefined') {\n      return self;\n    }\n\n    if (typeof window !== 'undefined') {\n      return window;\n    }\n\n    if (typeof global !== 'undefined') {\n      return global;\n    }\n\n    if (console && console.error) {\n      console.error('Unable to locate global object, returning \"this\".');\n    }\n  }();\n  /**\r\n   * @function copy\r\n   *\r\n   * @description\r\n   * copy an object deeply as much as possible\r\n   *\r\n   * If `strict` is applied, then all properties (including non-enumerable ones)\r\n   * are copied with their original property descriptors on both objects and arrays.\r\n   *\r\n   * The object is compared to the global constructors in the `realm` provided,\r\n   * and the native constructor is always used to ensure that extensions of native\r\n   * objects (allows in ES2015+) are maintained.\r\n   *\r\n   * @param object the object to copy\r\n   * @param [options] the options for copying with\r\n   * @param [options.isStrict] should the copy be strict\r\n   * @param [options.realm] the realm (this) object the object is copied from\r\n   * @returns the copied object\r\n   */\n\n\n  function copy(object, options) {\n    // manually coalesced instead of default parameters for performance\n    var isStrict = !!(options && options.isStrict);\n    var realm = options && options.realm || GLOBAL_THIS;\n    var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\n    /**\r\n     * @function handleCopy\r\n     *\r\n     * @description\r\n     * copy the object recursively based on its type\r\n     *\r\n     * @param object the object to copy\r\n     * @returns the copied object\r\n     */\n\n    var handleCopy = function (object, cache) {\n      if (!object || typeof object !== 'object') {\n        return object;\n      }\n\n      if (cache.has(object)) {\n        return cache.get(object);\n      }\n\n      var Constructor = object.constructor; // plain objects\n\n      if (Constructor === realm.Object) {\n        return getObjectClone(object, realm, handleCopy, cache);\n      }\n\n      var clone; // arrays\n\n      if (isArray(object)) {\n        // if strict, include non-standard properties\n        if (isStrict) {\n          return getObjectCloneStrict(object, realm, handleCopy, cache);\n        }\n\n        var length_1 = object.length;\n        clone = new Constructor();\n        cache.set(object, clone);\n\n        for (var index = 0; index < length_1; index++) {\n          clone[index] = handleCopy(object[index], cache);\n        }\n\n        return clone;\n      } // dates\n\n\n      if (object instanceof realm.Date) {\n        return new Constructor(object.getTime());\n      } // regexps\n\n\n      if (object instanceof realm.RegExp) {\n        clone = new Constructor(object.source, object.flags || getRegExpFlags(object));\n        clone.lastIndex = object.lastIndex;\n        return clone;\n      } // maps\n\n\n      if (realm.Map && object instanceof realm.Map) {\n        clone = new Constructor();\n        cache.set(object, clone);\n        object.forEach(function (value, key) {\n          clone.set(key, handleCopy(value, cache));\n        });\n        return clone;\n      } // sets\n\n\n      if (realm.Set && object instanceof realm.Set) {\n        clone = new Constructor();\n        cache.set(object, clone);\n        object.forEach(function (value) {\n          clone.add(handleCopy(value, cache));\n        });\n        return clone;\n      } // blobs\n\n\n      if (realm.Blob && object instanceof realm.Blob) {\n        return object.slice(0, object.size, object.type);\n      } // buffers (node-only)\n\n\n      if (realm.Buffer && realm.Buffer.isBuffer(object)) {\n        clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(object.length) : new Constructor(object.length);\n        cache.set(object, clone);\n        object.copy(clone);\n        return clone;\n      } // arraybuffers / dataviews\n\n\n      if (realm.ArrayBuffer) {\n        // dataviews\n        if (realm.ArrayBuffer.isView(object)) {\n          clone = new Constructor(object.buffer.slice(0));\n          cache.set(object, clone);\n          return clone;\n        } // arraybuffers\n\n\n        if (object instanceof realm.ArrayBuffer) {\n          clone = object.slice(0);\n          cache.set(object, clone);\n          return clone;\n        }\n      } // if the object cannot / should not be cloned, don't\n\n\n      if ( // promise-like\n      typeof object.then === 'function' || // errors\n      object instanceof Error || // weakmaps\n      realm.WeakMap && object instanceof realm.WeakMap || // weaksets\n      realm.WeakSet && object instanceof realm.WeakSet) {\n        return object;\n      } // assume anything left is a custom constructor\n\n\n      return getObjectClone(object, realm, handleCopy, cache);\n    };\n\n    return handleCopy(object, createCache());\n  } // Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n  // expects there to be a default property on the exported object. See\n  // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\n\n\n  copy.default = copy;\n  /**\r\n   * @function strictCopy\r\n   *\r\n   * @description\r\n   * copy the object with `strict` option pre-applied\r\n   *\r\n   * @param object the object to copy\r\n   * @param [options] the options for copying with\r\n   * @param [options.realm] the realm (this) object the object is copied from\r\n   * @returns the copied object\r\n   */\n\n  copy.strict = function strictCopy(object, options) {\n    return copy(object, {\n      isStrict: true,\n      realm: options ? options.realm : void 0\n    });\n  };\n\n  return copy;\n});","map":{"version":3,"mappings":"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","names":["toStringFunction","Function","prototype","toString","Object","defineProperty","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","getPrototypeOf","hasOwnProperty","propertyIsEnumerable","SUPPORTS","SYMBOL_PROPERTIES","WEAKMAP","WeakMap","createCache","object","create","has","key","_keys","indexOf","set","value","push","_values","get","getCleanClone","realm","constructor","Constructor","__proto__","call","getObjectCloneLoose","handleCopy","cache","clone","symbols","length_1","index","symbol","getObjectCloneStrict","properties","concat","length","property","descriptor","error","getRegExpFlags","regExp","flags","global","ignoreCase","multiline","unicode","sticky","Array","GLOBAL_THIS","self","window","console","copy","options","isStrict","getObjectClone","isArray","Date","getTime","RegExp","source","lastIndex","Map","forEach","Set","add","Blob","slice","size","type","Buffer","isBuffer","allocUnsafe","ArrayBuffer","isView","buffer","then","Error","WeakSet","default","strict","strictCopy"],"sources":["/Users/nagrawal/LC/blog-contentful-cms/blog-demo/node_modules/fast-copy/src/utils.ts","/Users/nagrawal/LC/blog-contentful-cms/blog-demo/node_modules/fast-copy/src/index.ts"],"sourcesContent":["const { toString: toStringFunction } = Function.prototype;\nconst {\n  create,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n  getPrototypeOf,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\n/**\n * @enum\n *\n * @const {Object} SUPPORTS\n *\n * @property {boolean} SYMBOL_PROPERTIES are symbol properties supported\n * @property {boolean} WEAKMAP is WeakMap supported\n */\nexport const SUPPORTS = {\n  SYMBOL_PROPERTIES: typeof getOwnPropertySymbols === 'function',\n  WEAKMAP: typeof WeakMap === 'function',\n};\n\n/**\n * @function createCache\n *\n * @description\n * get a new cache object to prevent circular references\n *\n * @returns the new cache object\n */\nexport const createCache = (): FastCopy.Cache => {\n  if (SUPPORTS.WEAKMAP) {\n    return new WeakMap();\n  }\n\n  // tiny implementation of WeakMap\n  const object = create({\n    has: (key: any) => !!~object._keys.indexOf(key),\n    set: (key: any, value: any) => {\n      object._keys.push(key);\n      object._values.push(value);\n    },\n    get: (key: any) => object._values[object._keys.indexOf(key)],\n  });\n\n  object._keys = [];\n  object._values = [];\n\n  return object;\n};\n\n/**\n * @function getCleanClone\n *\n * @description\n * get an empty version of the object with the same prototype it has\n *\n * @param object the object to build a clean clone from\n * @param realm the realm the object resides in\n * @returns the empty cloned object\n */\nexport const getCleanClone = (object: any, realm: FastCopy.Realm): any => {\n  if (!object.constructor) {\n    return create(null);\n  }\n\n  const { constructor: Constructor } = object;\n  const prototype = object.__proto__ || getPrototypeOf(object);\n\n  if (Constructor === realm.Object) {\n    return prototype === realm.Object.prototype ? {} : create(prototype);\n  }\n\n  if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n};\n\n/**\n * @function getObjectCloneLoose\n *\n * @description\n * get a copy of the object based on loose rules, meaning all enumerable keys\n * and symbols are copied, but property descriptors are not considered\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneLoose: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = handleCopy(object[key], cache);\n    }\n  }\n\n  if (SUPPORTS.SYMBOL_PROPERTIES) {\n    const symbols: symbol[] = getOwnPropertySymbols(object);\n\n    const { length } = symbols;\n\n    if (length) {\n      for (let index = 0, symbol; index < length; index++) {\n        symbol = symbols[index];\n\n        if (propertyIsEnumerable.call(object, symbol)) {\n          clone[symbol] = handleCopy(object[symbol], cache);\n        }\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getObjectCloneStrict\n *\n * @description\n * get a copy of the object based on strict rules, meaning all keys and symbols\n * are copied based on the original property descriptors\n *\n * @param object the object to clone\n * @param realm the realm the object resides in\n * @param handleCopy the function that handles copying the object\n * @returns the copied object\n */\nexport const getObjectCloneStrict: FastCopy.ObjectCloner = (\n  object: any,\n  realm: FastCopy.Realm,\n  handleCopy: FastCopy.Copier,\n  cache: FastCopy.Cache,\n): any => {\n  const clone: any = getCleanClone(object, realm);\n  // set in the cache immediately to be able to reuse the object recursively\n  cache.set(object, clone);\n\n  const properties: (string | symbol)[] = SUPPORTS.SYMBOL_PROPERTIES\n    ? getOwnPropertyNames(object).concat((getOwnPropertySymbols(object) as unknown) as string[])\n    : getOwnPropertyNames(object);\n\n  const { length } = properties;\n\n  if (length) {\n    for (let index = 0, property, descriptor; index < length; index++) {\n      property = properties[index];\n\n      if (property !== 'callee' && property !== 'caller') {\n        descriptor = getOwnPropertyDescriptor(object, property);\n\n        if (descriptor) {\n          // Only clone the value if actually a value, not a getter / setter.\n          if (!descriptor.get && !descriptor.set) {\n            descriptor.value = handleCopy(object[property], cache);\n          }\n\n          try {\n            defineProperty(clone, property, descriptor);\n          } catch (error) {\n            // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n            clone[property] = descriptor.value;\n          }\n        } else {\n          // In extra edge cases where the property descriptor cannot be retrived, fall back to\n          // the loose assignment.\n          clone[property] = handleCopy(object[property], cache);\n        }\n      }\n    }\n  }\n\n  return clone;\n};\n\n/**\n * @function getRegExpFlags\n *\n * @description\n * get the flags to apply to the copied regexp\n *\n * @param regExp the regexp to get the flags of\n * @returns the flags for the regexp\n */\nexport const getRegExpFlags = (regExp: RegExp): string => {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n};\n","// utils\nimport { createCache, getObjectCloneLoose, getObjectCloneStrict, getRegExpFlags } from './utils';\n\nconst { isArray } = Array;\n\nconst GLOBAL_THIS = (() => {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  if (console && console.error) {\n    console.error('Unable to locate global object, returning \"this\".');\n  }\n})();\n\n/**\n * @function copy\n *\n * @description\n * copy an object deeply as much as possible\n *\n * If `strict` is applied, then all properties (including non-enumerable ones)\n * are copied with their original property descriptors on both objects and arrays.\n *\n * The object is compared to the global constructors in the `realm` provided,\n * and the native constructor is always used to ensure that extensions of native\n * objects (allows in ES2015+) are maintained.\n *\n * @param object the object to copy\n * @param [options] the options for copying with\n * @param [options.isStrict] should the copy be strict\n * @param [options.realm] the realm (this) object the object is copied from\n * @returns the copied object\n */\nfunction copy<T>(object: T, options?: FastCopy.Options): T {\n  // manually coalesced instead of default parameters for performance\n  const isStrict: boolean = !!(options && options.isStrict);\n  const realm: FastCopy.Realm = (options && options.realm) || GLOBAL_THIS;\n\n  const getObjectClone: FastCopy.ObjectCloner = isStrict\n    ? getObjectCloneStrict\n    : getObjectCloneLoose;\n\n  /**\n   * @function handleCopy\n   *\n   * @description\n   * copy the object recursively based on its type\n   *\n   * @param object the object to copy\n   * @returns the copied object\n   */\n  const handleCopy: FastCopy.Copier = (object: any, cache: FastCopy.Cache): any => {\n    if (!object || typeof object !== 'object') {\n      return object;\n    } if (cache.has(object)) {\n      return cache.get(object);\n    }\n\n    const { constructor: Constructor } = object;\n\n    // plain objects\n    if (Constructor === realm.Object) {\n      return getObjectClone(object, realm, handleCopy, cache);\n    }\n\n    let clone: any;\n    // arrays\n    if (isArray(object)) {\n      // if strict, include non-standard properties\n      if (isStrict) {\n        return getObjectCloneStrict(object, realm, handleCopy, cache);\n      }\n\n      const { length } = object;\n\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      for (let index: number = 0; index < length; index++) {\n        clone[index] = handleCopy(object[index], cache);\n      }\n\n      return clone;\n    }\n\n    // dates\n    if (object instanceof realm.Date) {\n      return new Constructor(object.getTime());\n    }\n\n    // regexps\n    if (object instanceof realm.RegExp) {\n      clone = new Constructor(object.source, object.flags || getRegExpFlags(object));\n\n      clone.lastIndex = object.lastIndex;\n\n      return clone;\n    }\n\n    // maps\n    if (realm.Map && object instanceof realm.Map) {\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      object.forEach((value: any, key: any) => {\n        clone.set(key, handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // sets\n    if (realm.Set && object instanceof realm.Set) {\n      clone = new Constructor();\n      cache.set(object, clone);\n\n      object.forEach((value: any) => {\n        clone.add(handleCopy(value, cache));\n      });\n\n      return clone;\n    }\n\n    // blobs\n    if (realm.Blob && object instanceof realm.Blob) {\n      return object.slice(0, object.size, object.type);\n    }\n\n    // buffers (node-only)\n    if (realm.Buffer && realm.Buffer.isBuffer(object)) {\n      clone = realm.Buffer.allocUnsafe\n        ? realm.Buffer.allocUnsafe(object.length)\n        : new Constructor(object.length);\n\n      cache.set(object, clone);\n      object.copy(clone);\n\n      return clone;\n    }\n\n    // arraybuffers / dataviews\n    if (realm.ArrayBuffer) {\n      // dataviews\n      if (realm.ArrayBuffer.isView(object)) {\n        clone = new Constructor(object.buffer.slice(0));\n        cache.set(object, clone);\n        return clone;\n      }\n\n      // arraybuffers\n      if (object instanceof realm.ArrayBuffer) {\n        clone = object.slice(0);\n        cache.set(object, clone);\n        return clone;\n      }\n    }\n\n    // if the object cannot / should not be cloned, don't\n    if (\n      // promise-like\n      typeof object.then === 'function' ||\n      // errors\n      object instanceof Error ||\n      // weakmaps\n      (realm.WeakMap && object instanceof realm.WeakMap) ||\n      // weaksets\n      (realm.WeakSet && object instanceof realm.WeakSet)\n    ) {\n      return object;\n    }\n\n    // assume anything left is a custom constructor\n    return getObjectClone(object, realm, handleCopy, cache);\n  };\n\n  return handleCopy(object, createCache());\n}\n\n// Adding reference to allow usage in CommonJS libraries compiled using TSC, which\n// expects there to be a default property on the exported object. See\n// [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\ncopy.default = copy;\n\n/**\n * @function strictCopy\n *\n * @description\n * copy the object with `strict` option pre-applied\n *\n * @param object the object to copy\n * @param [options] the options for copying with\n * @param [options.realm] the realm (this) object the object is copied from\n * @returns the copied object\n */\ncopy.strict = function strictCopy(object: any, options?: FastCopy.Options) {\n  return copy(object, {\n    isStrict: true,\n    realm: options ? options.realm : void 0,\n  });\n};\n\nexport default copy;\n"]},"metadata":{},"sourceType":"script"}